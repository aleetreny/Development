<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Relativistic Black Hole Gravity Simulator</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", sans-serif;
    }
    html, body, #root {
      width: 100%;
      height: 100%;
    }
    .slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #22d3ee;
      cursor: pointer;
      border: 2px solid #000;
      box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
      transition: transform 0.1s;
    }
    .slider-thumb:hover {
      transform: scale(1.2);
      background: #67e8f9;
    }
    input[type="range"] {
      appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: #1a1a1a;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #22d3ee;
      cursor: pointer;
      border: 2px solid #000;
      box-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
      transition: transform 0.1s;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      background: #67e8f9;
    }
    input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #22d3ee;
      cursor: pointer;
      border: 2px solid #000;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // ============================================================================
    // PASO A: CONSTANTS
    // ============================================================================
    const GRAVITATIONAL_CONSTANT = 1.0;
    const SPEED_OF_LIGHT = 20;
    const MAX_SPEED = SPEED_OF_LIGHT * 0.9;
    const GRID_COLOR = 'rgba(6, 182, 212, 0.15)';
    const PARTICLE_COLOR = '#ffffff';
    const TRAIL_COLOR = 'rgba(103, 232, 249, 0.4)';
    const MAX_PARTICLES = 300;

    // ============================================================================
    // PASO B: ICON COMPONENTS (SVG Inline)
    // ============================================================================
    const IconPlay = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polygon points="5 3 19 12 5 21 5 3"></polygon>
      </svg>
    );

    const IconPause = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <rect x="6" y="4" width="4" height="16"></rect>
        <rect x="14" y="4" width="4" height="16"></rect>
      </svg>
    );

    const IconRefresh = () => (
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
        <polyline points="23 4 23 10 17 10"></polyline>
        <path d="M20.49 15a9 9 0 1 1-2-8.83"></path>
      </svg>
    );

    // ============================================================================
    // PASO C: SIMULATION CANVAS COMPONENT
    // ============================================================================
    const SimulationCanvas = ({ massMultiplier, gConstant, gridSpacing, timeScale }) => {
      const canvasRef = useRef(null);
      const requestRef = useRef(0);
      const particlesRef = useRef([]);
      const mousePosRef = useRef({ x: window.innerWidth / 2, y: window.innerHeight / 2 });
      const dimensionsRef = useRef({ width: 0, height: 0 });

      const getSchwarzschildRadius = useCallback((mass, g) => {
        return (2 * (g * 1000) * mass) / (SPEED_OF_LIGHT * SPEED_OF_LIGHT);
      }, []);

      const spawnParticle = (x, y, aimTowardsMouse = true) => {
        if (particlesRef.current.length >= MAX_PARTICLES) return;

        let vx = (Math.random() - 0.5) * 2;
        let vy = (Math.random() - 0.5) * 2;
        let ax = 0;
        let ay = 0;

        const Rs = getSchwarzschildRadius(massMultiplier, gConstant);
        const physicsG = gConstant * 1000;
        const GM = physicsG * massMultiplier;

        if (aimTowardsMouse) {
          const dx = mousePosRef.current.x - x;
          const dy = mousePosRef.current.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > Rs * 1.1) {
            const denominator = Math.pow(dist - Rs, 2);
            const orbitalSpeedSq = (GM * dist) / denominator;
            let orbitalSpeed = Math.sqrt(orbitalSpeedSq);
            orbitalSpeed = Math.min(orbitalSpeed, SPEED_OF_LIGHT * 0.95);

            const angle = Math.atan2(dy, dx);
            const tangentAngle = angle + (Math.PI / 2);
            vx = Math.cos(tangentAngle) * orbitalSpeed;
            vy = Math.sin(tangentAngle) * orbitalSpeed;

            const distFromHorizon = dist - Rs;
            const safeDist = Math.max(distFromHorizon, 1.0);
            const forceMagnitude = GM / (safeDist * safeDist);
            const clampedForce = Math.min(forceMagnitude, 50.0);
            ax = (dx / dist) * clampedForce;
            ay = (dy / dist) * clampedForce;
          }
        }

        const newParticle = {
          id: Date.now() + Math.random(),
          pos: { x, y },
          vel: { x: vx, y: vy },
          acc: { x: ax, y: ay },
          history: [],
          color: `hsl(${180 + Math.random() * 60}, 100%, 85%)`
        };

        particlesRef.current.push(newParticle);
      };

      const handleResize = useCallback(() => {
        if (canvasRef.current) {
          const { innerWidth, innerHeight } = window;
          canvasRef.current.width = innerWidth;
          canvasRef.current.height = innerHeight;
          dimensionsRef.current = { width: innerWidth, height: innerHeight };
          if (mousePosRef.current.x === 0 && mousePosRef.current.y === 0) {
            mousePosRef.current = { x: innerWidth / 2, y: innerHeight / 2 };
          }
        }
      }, []);

      useEffect(() => {
        window.addEventListener('resize', handleResize);
        handleResize();

        const animate = () => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          const width = canvas.width;
          const height = canvas.height;
          const mouse = mousePosRef.current;

          const physicsG = gConstant * 1000;
          const GM = physicsG * massMultiplier;
          const Rs = getSchwarzschildRadius(massMultiplier, gConstant);
          const photonSphereR = Rs * 1.5;

          ctx.fillStyle = '#000000';
          ctx.fillRect(0, 0, width, height);

          // Relativistic Lensing
          ctx.strokeStyle = GRID_COLOR;
          ctx.lineWidth = 1;
          ctx.beginPath();

          const einsteinDeflectionConstant = (4 * physicsG * massMultiplier) / (SPEED_OF_LIGHT * SPEED_OF_LIGHT);
          const visualLensingScale = 300;

          const getRelativisticDistortion = (ox, oy) => {
            const dx = ox - mouse.x;
            const dy = oy - mouse.y;
            const distSq = dx * dx + dy * dy;

            if (distSq > 250000) return { x: ox, y: oy };

            const dist = Math.sqrt(distSq);
            if (dist < Rs) {
              return { x: ox, y: oy };
            }

            const displacementMagnitude = (einsteinDeflectionConstant / dist) * visualLensingScale;
            const angle = Math.atan2(dy, dx);
            const clampedDisplacement = Math.min(displacementMagnitude, dist - Rs);

            return {
              x: ox - Math.cos(angle) * clampedDisplacement,
              y: oy - Math.sin(angle) * clampedDisplacement
            };
          };

          const drawStep = Math.max(15, gridSpacing / 1.5);

          for (let y = 0; y <= height; y += gridSpacing) {
            let first = true;
            for (let x = 0; x <= width; x += drawStep) {
              const p = getRelativisticDistortion(x, y);
              if (first) {
                ctx.moveTo(p.x, p.y);
                first = false;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }

          for (let x = 0; x <= width; x += gridSpacing) {
            let first = true;
            for (let y = 0; y <= height; y += drawStep) {
              const p = getRelativisticDistortion(x, y);
              if (first) {
                ctx.moveTo(p.x, p.y);
                first = false;
              } else {
                ctx.lineTo(p.x, p.y);
              }
            }
          }

          ctx.stroke();

          // Physics
          const activeParticles = [];
          const horizonRadiusSq = Rs * Rs;
          const dt = timeScale;
          const dtSqHalf = 0.5 * dt * dt;

          particlesRef.current.forEach(p => {
            const nextX = p.pos.x + p.vel.x * dt + p.acc.x * dtSqHalf;
            const nextY = p.pos.y + p.vel.y * dt + p.acc.y * dtSqHalf;

            const dx = mouse.x - nextX;
            const dy = mouse.y - nextY;
            const distSq = dx * dx + dy * dy;

            if (distSq < horizonRadiusSq) {
              return;
            }

            const dist = Math.sqrt(distSq);
            const distFromHorizon = dist - Rs;
            const safeDist = Math.max(distFromHorizon, 1.0);
            const forceMagnitude = GM / (safeDist * safeDist);
            const clampedForce = Math.min(forceMagnitude, 50.0);

            const nextAccX = (dx / dist) * clampedForce;
            const nextAccY = (dy / dist) * clampedForce;

            let nextVelX = p.vel.x + 0.5 * (p.acc.x + nextAccX) * dt;
            let nextVelY = p.vel.y + 0.5 * (p.acc.y + nextAccY) * dt;

            const currentSpeed = Math.sqrt(nextVelX * nextVelX + nextVelY * nextVelY);
            if (currentSpeed > MAX_SPEED) {
              const ratio = MAX_SPEED / currentSpeed;
              nextVelX *= ratio;
              nextVelY *= ratio;
            }

            p.pos.x = nextX;
            p.pos.y = nextY;
            p.vel.x = nextVelX;
            p.vel.y = nextVelY;
            p.acc.x = nextAccX;
            p.acc.y = nextAccY;

            p.history.push({ ...p.pos });
            if (p.history.length > 25) {
              p.history.shift();
            }

            if (p.history.length > 1) {
              ctx.beginPath();
              ctx.strokeStyle = p.color;
              ctx.lineWidth = 1.5;
              ctx.moveTo(p.history[0].x, p.history[0].y);
              for (let i = 1; i < p.history.length; i++) {
                ctx.globalAlpha = (i / p.history.length) * 0.6;
                ctx.lineTo(p.history[i].x, p.history[i].y);
              }
              ctx.stroke();
              ctx.globalAlpha = 1.0;
            }

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.pos.x, p.pos.y, 2, 0, Math.PI * 2);
            ctx.fill();

            if (p.pos.x > -3000 && p.pos.x < width + 3000 && p.pos.y > -3000 && p.pos.y < height + 3000) {
              activeParticles.push(p);
            }
          });

          particlesRef.current = activeParticles;

          // Black Hole
          const accretionOuter = Rs * 4.0;
          const accretionInner = Rs * 1.1;
          const gradient = ctx.createRadialGradient(mouse.x, mouse.y, accretionInner, mouse.x, mouse.y, accretionOuter);
          gradient.addColorStop(0, '#000');
          gradient.addColorStop(0.1, '#fff');
          gradient.addColorStop(0.2, 'rgba(34, 211, 238, 1)');
          gradient.addColorStop(0.6, 'rgba(6, 182, 212, 0.2)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(mouse.x, mouse.y, accretionOuter, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#000000';
          ctx.beginPath();
          ctx.arc(mouse.x, mouse.y, Rs, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.arc(mouse.x, mouse.y, photonSphereR, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalAlpha = 1.0;

          requestRef.current = requestAnimationFrame(animate);
        };

        requestRef.current = requestAnimationFrame(animate);

        return () => {
          window.removeEventListener('resize', handleResize);
          if (requestRef.current) cancelAnimationFrame(requestRef.current);
        };
      }, [handleResize, massMultiplier, gConstant, gridSpacing, timeScale, getSchwarzschildRadius]);

      const handleMouseMove = (e) => {
        mousePosRef.current = { x: e.clientX, y: e.clientY };
      };

      const handleMouseDown = (e) => {
        for (let i = 0; i < 12; i++) {
          const side = Math.floor(Math.random() * 4);
          let sx = 0, sy = 0;
          const w = window.innerWidth;
          const h = window.innerHeight;
          switch (side) {
            case 0:
              sx = Math.random() * w;
              sy = -50;
              break;
            case 1:
              sx = w + 50;
              sy = Math.random() * h;
              break;
            case 2:
              sx = Math.random() * w;
              sy = h + 50;
              break;
            case 3:
              sx = -50;
              sy = Math.random() * h;
              break;
          }
          spawnParticle(sx, sy);
        }
      };

      return (
        <canvas
          ref={canvasRef}
          onMouseMove={handleMouseMove}
          onMouseDown={handleMouseDown}
          className="absolute top-0 left-0 w-full h-full cursor-none"
        />
      );
    };

    // ============================================================================
    // PASO C: CONTROLS COMPONENT
    // ============================================================================
    const Controls = ({ mass, setMass, gConstant, setGConstant, gridSpacing, setGridSpacing, timeScale, setTimeScale }) => {
      return (
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/80 to-transparent px-6 py-4 pointer-events-none">
          <div className="max-w-2xl mx-auto pointer-events-auto">
            <div className="grid grid-cols-2 gap-6 mb-4 text-white text-sm">
              {/* Mass Multiplier */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="font-mono text-cyan-400">Mass Multiplier</label>
                  <span className="text-cyan-300 font-bold">{mass.toFixed(2)}</span>
                </div>
                <input
                  type="range"
                  min="1"
                  max="12"
                  step="0.1"
                  value={mass}
                  onChange={(e) => setMass(parseFloat(e.target.value))}
                  className="w-full"
                />
              </div>

              {/* G Constant */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="font-mono text-cyan-400">G Constant</label>
                  <span className="text-cyan-300 font-bold">{gConstant.toFixed(2)}</span>
                </div>
                <input
                  type="range"
                  min="0.1"
                  max="2.0"
                  step="0.05"
                  value={gConstant}
                  onChange={(e) => setGConstant(parseFloat(e.target.value))}
                  className="w-full"
                />
              </div>

              {/* Grid Spacing */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="font-mono text-cyan-400">Grid Spacing</label>
                  <span className="text-cyan-300 font-bold">{gridSpacing.toFixed(0)}</span>
                </div>
                <input
                  type="range"
                  min="10"
                  max="100"
                  step="5"
                  value={gridSpacing}
                  onChange={(e) => setGridSpacing(parseFloat(e.target.value))}
                  className="w-full"
                />
              </div>

              {/* Time Scale */}
              <div>
                <div className="flex justify-between items-center mb-2">
                  <label className="font-mono text-cyan-400">Time Scale</label>
                  <span className="text-cyan-300 font-bold">{timeScale.toFixed(2)}</span>
                </div>
                <input
                  type="range"
                  min="0.1"
                  max="2.0"
                  step="0.1"
                  value={timeScale}
                  onChange={(e) => setTimeScale(parseFloat(e.target.value))}
                  className="w-full"
                />
              </div>
            </div>

            <div className="text-xs text-cyan-900 font-mono tracking-widest opacity-60 mt-4">
              LEFT CLICK: Spawn Particles • SCROLL: Adjust Mass • MOVE MOUSE: Control Black Hole
            </div>
          </div>
        </div>
      );
    };

    // ============================================================================
    // PASO D: APP COMPONENT PRINCIPAL
    // ============================================================================
    const App = () => {
      const [mass, setMass] = useState(4.0);
      const [gConstant, setGConstant] = useState(0.8);
      const [gridSpacing, setGridSpacing] = useState(30);
      const [timeScale, setTimeScale] = useState(1.0);

      useEffect(() => {
        const handleWheel = (e) => {
          setMass((prevMass) => {
            const delta = e.deltaY * 0.01;
            const newMass = Math.max(1.0, Math.min(prevMass - delta, 12.0));
            return newMass;
          });
        };

        window.addEventListener('wheel', handleWheel);
        return () => window.removeEventListener('wheel', handleWheel);
      }, []);

      return (
        <div className="relative w-full h-screen bg-black overflow-hidden font-sans">
          <SimulationCanvas
            massMultiplier={mass}
            gConstant={gConstant}
            gridSpacing={gridSpacing}
            timeScale={timeScale}
          />
          <Controls
            mass={mass}
            setMass={setMass}
            gConstant={gConstant}
            setGConstant={setGConstant}
            gridSpacing={gridSpacing}
            setGridSpacing={setGridSpacing}
            timeScale={timeScale}
            setTimeScale={setTimeScale}
          />
          <div className="absolute bottom-4 right-6 text-cyan-900 text-xs tracking-widest pointer-events-none opacity-50">
            CANVAS API // PHYSICS ENGINE // REACT 19
          </div>
        </div>
      );
    };

    // ============================================================================
    // INICIALIZACIÓN: MONTAR LA APP
    // ============================================================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
